var documenterSearchIndex = {"docs":
[{"location":"gf/#Single-particle-Green's-functions","page":"Single-particle Green's functions","title":"Single-particle Green's functions","text":"","category":"section"},{"location":"gf/","page":"Single-particle Green's functions","title":"Single-particle Green's functions","text":"CurrentModule = KeldyshED","category":"page"},{"location":"gf/#computegf()","page":"Single-particle Green's functions","title":"computegf()","text":"","category":"section"},{"location":"gf/","page":"Single-particle Green's functions","title":"Single-particle Green's functions","text":"computegf(::EDCore,\n          ::BranchPoint, ::BranchPoint,\n          ::IndicesType, ::IndicesType,\n          ::Float64)\ncomputegf(::EDCore,\n          ::BranchPoint, ::BranchPoint,\n          ::IndicesType, ::IndicesType;\n          en, ρ)\ncomputegf(::EDCore,\n          ::FullTimeGrid,\n          ::IndicesType, ::IndicesType;\n          ::AbstractGFFiller)\ncomputegf(::EDCore,\n          ::KeldyshTimeGrid,\n          ::IndicesType, ::IndicesType,\n          ::Float64;\n          ::AbstractGFFiller)\ncomputegf(::EDCore,\n          ::ImaginaryTimeGrid,\n          ::IndicesType, ::IndicesType;\n          ::AbstractGFFiller)\ncomputegf(::EDCore,\n          ::FullTimeGrid,\n          ::Vector{Tuple{IndicesType, IndicesType}};\n          ::AbstractGFFiller)\ncomputegf(::EDCore,\n          ::KeldyshTimeGrid,\n          ::Vector{Tuple{IndicesType, IndicesType}},\n          ::Float64;\n          ::AbstractGFFiller)\ncomputegf(::EDCore,\n          ::ImaginaryTimeGrid,\n          ::Vector{Tuple{IndicesType, IndicesType}};\n          ::AbstractGFFiller)\ncomputegf(::EDCore,\n          ::FullTimeGrid,\n          ::Vector{IndicesType}, ::Vector{IndicesType};\n          ::AbstractGFFiller)\ncomputegf(::EDCore,\n          ::KeldyshTimeGrid,\n          ::Vector{IndicesType}, ::Vector{IndicesType},\n          ::Float64;\n          ::AbstractGFFiller)\ncomputegf(::EDCore,\n          ::ImaginaryTimeGrid,\n          ::Vector{IndicesType}, ::Vector{IndicesType};\n          ::AbstractGFFiller)","category":"page"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.BranchPoint, Keldysh.BranchPoint, Vector{Union{Int64, String}}, Vector{Union{Int64, String}}, Float64}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    t1::Keldysh.BranchPoint,\n    t2::Keldysh.BranchPoint,\n    c_index::Vector{Union{Int64, String}},\n    cdag_index::Vector{Union{Int64, String}},\n    β::Float64\n) -> ComplexF64\n\n\nCompute single-particle Keldysh Green's function\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\nquad hatrho = frace^-betahat HmathrmTre^-betahat H\n\nat given contour times t_1, t_2 for given compound indices of creation/annihilation operators i and j.\n\nArguments\n\ned:         Exact Diagonalization object.\nt1:         Contour time t_1.\nt2:         Contour time t_2.\nc_index:    Compound index i.\ncdag_index: Compound index j.\nβ:          Inverse temperature beta.\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.BranchPoint, Keldysh.BranchPoint, Vector{Union{Int64, String}}, Vector{Union{Int64, String}}}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    t1::Keldysh.BranchPoint,\n    t2::Keldysh.BranchPoint,\n    c_index::Vector{Union{Int64, String}},\n    cdag_index::Vector{Union{Int64, String}};\n    en,\n    ρ\n)\n\n\nCompute single-particle Keldysh Green's function\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\n\nat given contour times t_1, t_2 for given compound indices of creation/annihilation operators i and j. This method is useful if the density matrix hatrho has already been computed.\n\nArguments\n\ned:         Exact Diagonalization object.\nt1:         Contour time t_1.\nt2:         Contour time t_2.\nc_index:    Compound index i.\ncdag_index: Compound index j.\nen:         Energy levels of the system as returned by               energies().\nρ           Density matrix hatrho as returned by               density_matrix().\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.FullTimeGrid, Vector{Union{Int64, String}}, Vector{Union{Int64, String}}}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    grid::Keldysh.FullTimeGrid,\n    c_index::Vector{Union{Int64, String}},\n    cdag_index::Vector{Union{Int64, String}};\n    gf_filler\n) -> Keldysh.TimeInvariantFullTimeGF{ComplexF64, true}\n\n\nCompute single-particle Keldysh Green's function\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\n\non a 3-branch Konstantinov-Perel' contour for given compound indices of creation/annihilation operators i and j.\n\nArguments\n\ned:         Exact Diagonalization object.\ngrid:       Time grid on the 3-branch contour.\nc_index:    Compound index i.\ncdag_index: Compound index j.\ngf_filler:  Algorithm selector for GF computation.\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.KeldyshTimeGrid, Vector{Union{Int64, String}}, Vector{Union{Int64, String}}, Float64}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    grid::Keldysh.KeldyshTimeGrid,\n    c_index::Vector{Union{Int64, String}},\n    cdag_index::Vector{Union{Int64, String}},\n    β::Float64;\n    gf_filler\n) -> Keldysh.TimeInvariantKeldyshTimeGF{ComplexF64, true}\n\n\nCompute single-particle Keldysh Green's function\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\nquad hatrho = frace^-betahat HmathrmTre^-betahat H\n\non a 2-branch Keldysh contour for given compound indices of creation/annihilation operators i and j with a decoupled initial thermal state at inverse temperature beta.\n\nArguments\n\ned:         Exact Diagonalization object.\ngrid:       Time grid on the 2-branch contour.\nc_index:    Compound index i.\ncdag_index: Compound index j.\nβ:          Inverse temperature beta.\ngf_filler:  Algorithm selector for GF computation.\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.ImaginaryTimeGrid, Vector{Union{Int64, String}}, Vector{Union{Int64, String}}}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    grid::Keldysh.ImaginaryTimeGrid,\n    c_index::Vector{Union{Int64, String}},\n    cdag_index::Vector{Union{Int64, String}};\n    gf_filler\n) -> Keldysh.ImaginaryTimeGF{ComplexF64, true}\n\n\nCompute single-particle Keldysh Green's function\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\n\non the imaginary time segment 0-ibeta for given compound indices of creation/annihilation operators i and j.\n\nArguments\n\ned:         Exact Diagonalization object.\ngrid:       Time grid on the imaginary time segment.\nc_index:    Compound index i.\ncdag_index: Compound index j.\ngf_filler:  Algorithm selector for GF computation.\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.FullTimeGrid, Vector{Tuple{Vector{Union{Int64, String}}, Vector{Union{Int64, String}}}}}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    grid::Keldysh.FullTimeGrid,\n    c_cdag_index_pairs::Vector{Tuple{Vector{Union{Int64, String}}, Vector{Union{Int64, String}}}};\n    gf_filler\n) -> Vector{Keldysh.TimeInvariantFullTimeGF{ComplexF64, true}}\n\n\nCompute multiple single-particle Keldysh Green's functions\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\n\non a 3-branch Konstantinov-Perel' contour for given compound indices of creation/annihilation operators i and j.\n\nArguments\n\ned:                 Exact Diagonalization object.\ngrid:               Time grid on the 3-branch contour.\nc_cdag_index_pairs: List of compound index pairs (i j).\ngf_filler:          Algorithm selector for GF computation.\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.KeldyshTimeGrid, Vector{Tuple{Vector{Union{Int64, String}}, Vector{Union{Int64, String}}}}, Float64}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    grid::Keldysh.KeldyshTimeGrid,\n    c_cdag_index_pairs::Vector{Tuple{Vector{Union{Int64, String}}, Vector{Union{Int64, String}}}},\n    β::Float64;\n    gf_filler\n) -> Vector{Keldysh.TimeInvariantKeldyshTimeGF{ComplexF64, true}}\n\n\nCompute multiple single-particle Keldysh Green's functions\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\nquad hatrho = frace^-betahat HmathrmTre^-betahat H\n\non a 2-branch Keldysh contour for given compound indices of creation/annihilation operators i and j with a decoupled initial thermal state at inverse temperature beta.\n\nArguments\n\ned:                 Exact Diagonalization object.\ngrid:               Time grid on the 2-branch contour.\nc_cdag_index_pairs: List of compound index pairs (i j).\nβ:                  Inverse temperature beta.\ngf_filler:          Algorithm selector for GF computation.\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.ImaginaryTimeGrid, Vector{Tuple{Vector{Union{Int64, String}}, Vector{Union{Int64, String}}}}}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    grid::Keldysh.ImaginaryTimeGrid,\n    c_cdag_index_pairs::Vector{Tuple{Vector{Union{Int64, String}}, Vector{Union{Int64, String}}}};\n    gf_filler\n) -> Vector{Keldysh.ImaginaryTimeGF{ComplexF64, true}}\n\n\nCompute multiple single-particle Keldysh Green's functions\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\n\non the imaginary time segment 0-ibeta for given compound indices of creation/annihilation operators i and j.\n\nArguments\n\ned:                 Exact Diagonalization object.\ngrid:               Time grid on the imaginary time segment.\nc_cdag_index_pairs: List of compound index pairs (i j).\ngf_filler:          Algorithm selector for GF computation.\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.FullTimeGrid, Vector{Vector{Union{Int64, String}}}, Vector{Vector{Union{Int64, String}}}}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    grid::Keldysh.FullTimeGrid,\n    c_indices::Vector{Vector{Union{Int64, String}}},\n    cdag_indices::Vector{Vector{Union{Int64, String}}};\n    gf_filler\n) -> Keldysh.TimeInvariantFullTimeGF{ComplexF64, false}\n\n\nCompute a matrix-valued single-particle Keldysh Green's function\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\n\non a 3-branch Konstantinov-Perel' contour for all possible pairs of compound indices (i j) given a list of i and a list of j (the lists must have equal length).\n\nArguments\n\ned:           Exact Diagonalization object.\ngrid:         Time grid on the 3-branch contour.\nc_indices:    List of compound indices i.\ncdag_indices: List of compound indices j.\ngf_filler:    Algorithm selector for GF computation.\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.KeldyshTimeGrid, Vector{Vector{Union{Int64, String}}}, Vector{Vector{Union{Int64, String}}}, Float64}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    grid::Keldysh.KeldyshTimeGrid,\n    c_indices::Vector{Vector{Union{Int64, String}}},\n    cdag_indices::Vector{Vector{Union{Int64, String}}},\n    β::Float64;\n    gf_filler\n) -> Keldysh.TimeInvariantKeldyshTimeGF{ComplexF64, false}\n\n\nCompute a matrix-valued single-particle Keldysh Green's function\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\nquad hatrho = frace^-betahat HmathrmTre^-betahat H\n\non a 2-branch Keldysh contour for all possible pairs of compound indices (i j) given a list of i and a list of j (the lists must have equal length).\n\nArguments\n\ned:           Exact Diagonalization object.\ngrid:         Time grid on the 2-branch contour.\nc_indices:    List of compound indices i.\ncdag_indices: List of compound indices j.\nβ:            Inverse temperature beta.\ngf_filler:    Algorithm selector for GF computation.\n\n\n\n\n\n","category":"method"},{"location":"gf/#KeldyshED.computegf-Tuple{EDCore, Keldysh.ImaginaryTimeGrid, Vector{Vector{Union{Int64, String}}}, Vector{Vector{Union{Int64, String}}}}","page":"Single-particle Green's functions","title":"KeldyshED.computegf","text":"computegf(\n    ed::EDCore,\n    grid::Keldysh.ImaginaryTimeGrid,\n    c_indices::Vector{Vector{Union{Int64, String}}},\n    cdag_indices::Vector{Vector{Union{Int64, String}}};\n    gf_filler\n) -> Keldysh.ImaginaryTimeGF{ComplexF64, false}\n\n\nCompute a matrix-valued single-particle Keldysh Green's function\n\nG_ij(t_1 t_2) =\n-i mathrmTrhatrho mathbbT_mathcalC c_i(t_1) c^dagger_j(t_2)\n\non the imaginary time segment 0-ibeta for all possible pairs of compound indices (i j) given a list of i and a list of j (the lists must have equal length).\n\nArguments\n\ned:           Exact Diagonalization object.\ngrid:         Time grid on the imaginary time segment.\nc_indices:    List of compound indices i.\ncdag_indices: List of compound indices j.\ngf_filler:    Algorithm selector for GF computation.\n\n\n\n\n\n","category":"method"},{"location":"gf/#Auxiliary-types","page":"Single-particle Green's functions","title":"Auxiliary types","text":"","category":"section"},{"location":"gf/","page":"Single-particle Green's functions","title":"Single-particle Green's functions","text":"AbstractGFFiller\nSerialGFFiller\nDistributedGFFiller","category":"page"},{"location":"gf/#KeldyshED.AbstractGFFiller","page":"Single-particle Green's functions","title":"KeldyshED.AbstractGFFiller","text":"Abstract supertype for GF filler types.\n\n\n\n\n\n","category":"type"},{"location":"gf/#KeldyshED.SerialGFFiller","page":"Single-particle Green's functions","title":"KeldyshED.SerialGFFiller","text":"An argument of this type instructs Green's function computation routines to use a serial (non-parallelized) algorithm.\n\n\n\n\n\n","category":"type"},{"location":"gf/#KeldyshED.DistributedGFFiller","page":"Single-particle Green's functions","title":"KeldyshED.DistributedGFFiller","text":"An argument of this type instructs Green's function computation routines to use Distributed.@distributed to speed up calculation.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Expressions-with-creation/annihilation-operators-of-fermions","page":"Expressions with creation/annihilation operators of fermions","title":"Expressions with creation/annihilation operators of fermions","text":"","category":"section"},{"location":"operators/","page":"Expressions with creation/annihilation operators of fermions","title":"Expressions with creation/annihilation operators of fermions","text":"KeldyshED.Operators","category":"page"},{"location":"operators/#KeldyshED.Operators","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators","text":"This module implements an algebra of fermionic creation/annihilation operators and polynomial expressions built out of such operators.\n\n\n\n\n\n","category":"module"},{"location":"operators/","page":"Expressions with creation/annihilation operators of fermions","title":"Expressions with creation/annihilation operators of fermions","text":"CurrentModule = KeldyshED.Operators","category":"page"},{"location":"operators/#Canonical-operators","page":"Expressions with creation/annihilation operators of fermions","title":"Canonical operators","text":"","category":"section"},{"location":"operators/","page":"Expressions with creation/annihilation operators of fermions","title":"Expressions with creation/annihilation operators of fermions","text":"IndicesType\nCanonicalOperator\ndagger(op::CanonicalOperator)\nisconjugate(op1::CanonicalOperator, op2::CanonicalOperator)\nBase.show(io::IO, op::CanonicalOperator)","category":"page"},{"location":"operators/#KeldyshED.Operators.IndicesType","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.IndicesType","text":"mutable struct Array{Union{Int64, String}, 1} <: DenseVector{Union{Int64, String}}\n\nCompound operator index alpha as a mixed list of String / Int indices.\n\n\n\n\n\n","category":"type"},{"location":"operators/#KeldyshED.Operators.CanonicalOperator","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.CanonicalOperator","text":"This structure represents a single creation operator c^dagger_alpha or an annihilation operator c_alpha.\n\nFields\n\ndagger::Bool: Creation operator if true, annihilation operator otherwise\nindices::Vector{Union{Int64, String}}: Compound index α carried by the operator\n\nCanonical operators are less-comparable and are ordered according to the following rule,\n\nc^dagger_alpha  c^dagger_beta  c^dagger_gamma      c_gamma  c_beta  c_alpha\n\nwhere compound indices satisfy alpha  beta  gamma.\n\n\n\n\n\n","category":"type"},{"location":"operators/#KeldyshED.Operators.dagger-Tuple{KeldyshED.Operators.CanonicalOperator}","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.dagger","text":"dagger(\n    op::KeldyshED.Operators.CanonicalOperator\n) -> KeldyshED.Operators.CanonicalOperator\n\n\nHermitian conjugate of a canonical operator.\n\n\n\n\n\n","category":"method"},{"location":"operators/#KeldyshED.Operators.isconjugate-Tuple{KeldyshED.Operators.CanonicalOperator, KeldyshED.Operators.CanonicalOperator}","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.isconjugate","text":"isconjugate(\n    op1::KeldyshED.Operators.CanonicalOperator,\n    op2::KeldyshED.Operators.CanonicalOperator\n) -> Bool\n\n\nCheck if op2 is a Hermitian conjugate of op1.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.show-Tuple{IO, KeldyshED.Operators.CanonicalOperator}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.show","text":"show(io::IO, op::KeldyshED.Operators.CanonicalOperator)\n\n\nPrint a canonical operator.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Monomials","page":"Expressions with creation/annihilation operators of fermions","title":"Monomials","text":"","category":"section"},{"location":"operators/","page":"Expressions with creation/annihilation operators of fermions","title":"Expressions with creation/annihilation operators of fermions","text":"Monomial\nBase.length(m::Monomial)\nBase.isempty(m::Monomial)\ndagger(m::Monomial)\nBase.show(io::IO, m::Monomial)","category":"page"},{"location":"operators/#KeldyshED.Operators.Monomial","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.Monomial","text":"An ordered product of canonical operators.\n\nFields\n\nops::Vector{KeldyshED.Operators.CanonicalOperator}: List of canonical operators in the product, left-to-right.\n\nMonomials are less-comparable, with a shorter monomial being always considered lesser than a longer one.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Base.length-Tuple{KeldyshED.Operators.Monomial}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.length","text":"length(m::KeldyshED.Operators.Monomial) -> Int64\n\n\nNumber of canonical operators in a given monomial.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.isempty-Tuple{KeldyshED.Operators.Monomial}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.isempty","text":"isempty(m::KeldyshED.Operators.Monomial) -> Any\n\n\nCheck if a given monomial is 1, i.e. a product of zero canonical operators.\n\n\n\n\n\n","category":"method"},{"location":"operators/#KeldyshED.Operators.dagger-Tuple{KeldyshED.Operators.Monomial}","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.dagger","text":"dagger(\n    m::KeldyshED.Operators.Monomial\n) -> KeldyshED.Operators.Monomial\n\n\nHermitian conjugate of a monomial.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.show-Tuple{IO, KeldyshED.Operators.Monomial}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.show","text":"show(io::IO, m::KeldyshED.Operators.Monomial)\n\n\nPrint a monomial.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Polynomial-expressions","page":"Expressions with creation/annihilation operators of fermions","title":"Polynomial expressions","text":"","category":"section"},{"location":"operators/","page":"Expressions with creation/annihilation operators of fermions","title":"Expressions with creation/annihilation operators of fermions","text":"OperatorExpr\nOperatorExpr{S}(x::S) where {S <: Number}\nRealOperatorExpr\nComplexOperatorExpr\nscalartype\ndagger(op::OperatorExpr{S}) where S\nBase.iszero(op::OperatorExpr)\nBase.length(op::OperatorExpr)\nBase.isempty(op::OperatorExpr)\nBase.map(f, op::OperatorExpr)\nBase.real(op::OperatorExpr)\nBase.imag(op::OperatorExpr)\nBase.show(io::IO, op::OperatorExpr)","category":"page"},{"location":"operators/#KeldyshED.Operators.OperatorExpr","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.OperatorExpr","text":"Polynomial expression built out of canonical operators and numeric coefficients,\n\nM^(0) + sum_alpha M^(1)_alpha o_alpha +     sum_alphabeta M^(2)_alphabeta o_alpha o_beta +     sum_alphabetagamma M^(3)_alphabetagamma         o_alpha o_beta o_gamma + ldots\n\nwhere o_alpha are canonical operators c^dagger_alpha / c_alpha, and M^(n) are the coefficients.\n\nFields\n\nmonomials::DataStructures.SortedDict{KeldyshED.Operators.Monomial, ScalarType} where ScalarType<:Number: Sorted list of monomials with numeric coefficients M^(n) in front of them.\n\nPolynomial expressions support the following arithmetic operations.\n\nAddition / subtraction of two expressions with the same coefficient type.\nMultiplication of two expressions with the same coefficient type.\nAddition / subtraction of a constant.\nMultiplication / division by a constant.\nUnary minus.\n\nThey also support the iteration interface with iteration element type being Pair{Monomial, ScalarType}.\n\n\n\n\n\n","category":"type"},{"location":"operators/#KeldyshED.Operators.OperatorExpr-Tuple{S} where S<:Number","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.OperatorExpr","text":"OperatorExpr{S}(x::S) where {S <: Number}\n\nConstruct a polynomial expression with coefficient type S identically equal to x.\n\n\n\n\n\n","category":"method"},{"location":"operators/#KeldyshED.Operators.RealOperatorExpr","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.RealOperatorExpr","text":"struct OperatorExpr{Float64}\n\nPolynomial expression with real coefficients.\n\n\n\n\n\n","category":"type"},{"location":"operators/#KeldyshED.Operators.ComplexOperatorExpr","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.ComplexOperatorExpr","text":"struct OperatorExpr{ComplexF64}\n\nPolynomial expression with complex coefficients.\n\n\n\n\n\n","category":"type"},{"location":"operators/#KeldyshED.Operators.scalartype","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.scalartype","text":"scalartype(_::KeldyshED.Operators.OperatorExpr{S}) -> Any\n\n\nDetermine the type of monomial coefficients of a given polynomial expression.\n\n\n\n\n\nscalartype(\n    _::Type{KeldyshED.Operators.OperatorExpr{S}}\n) -> Any\n\n\nDetermine the type of monomial coefficients of a given polynomial expression type.\n\n\n\n\n\n","category":"function"},{"location":"operators/#KeldyshED.Operators.dagger-Union{Tuple{KeldyshED.Operators.OperatorExpr{S}}, Tuple{S}} where S","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.dagger","text":"dagger(\n    op::KeldyshED.Operators.OperatorExpr{S}\n) -> KeldyshED.Operators.OperatorExpr\n\n\nHermitian conjugate of a polynomial expression.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.iszero-Tuple{KeldyshED.Operators.OperatorExpr}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.iszero","text":"iszero(op::KeldyshED.Operators.OperatorExpr{S}) -> Bool\n\n\nCheck if a given polynomial expression is identically zero.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.length-Tuple{KeldyshED.Operators.OperatorExpr}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.length","text":"length(op::KeldyshED.Operators.OperatorExpr) -> Int64\n\n\nNumber of monomials in a given polynomial expression op.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.isempty-Tuple{KeldyshED.Operators.OperatorExpr}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.isempty","text":"isempty(op::KeldyshED.Operators.OperatorExpr) -> Bool\n\n\nCheck if a given polynomial expression is identically zero.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.map-Tuple{Any, KeldyshED.Operators.OperatorExpr}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.map","text":"map(\n    f,\n    op::KeldyshED.Operators.OperatorExpr{S}\n) -> KeldyshED.Operators.OperatorExpr\n\n\nTransform a given polynomial expression op by applying a function f to coefficients of all monomials in the expression. If f applied to a coefficient returns zero, the corresponding monomial is omitted from the resulting expression.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.real-Tuple{KeldyshED.Operators.OperatorExpr}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.real","text":"real(\n    op::KeldyshED.Operators.OperatorExpr\n) -> KeldyshED.Operators.OperatorExpr\n\n\nReturn a version of a polynomial expression op with all coefficients replaced by their real parts.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.imag-Tuple{KeldyshED.Operators.OperatorExpr}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.imag","text":"imag(\n    op::KeldyshED.Operators.OperatorExpr\n) -> KeldyshED.Operators.OperatorExpr\n\n\nReturn a version of a polynomial expression op with all coefficients replaced by their imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.show-Tuple{IO, KeldyshED.Operators.OperatorExpr}","page":"Expressions with creation/annihilation operators of fermions","title":"Base.show","text":"show(io::IO, op::KeldyshED.Operators.OperatorExpr{S}) -> Any\n\n\nPrint a polynomial expression.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Factory-functions-for-polynomial-expressions","page":"Expressions with creation/annihilation operators of fermions","title":"Factory functions for polynomial expressions","text":"","category":"section"},{"location":"operators/","page":"Expressions with creation/annihilation operators of fermions","title":"Expressions with creation/annihilation operators of fermions","text":"c\nc_dag\nn","category":"page"},{"location":"operators/#KeldyshED.Operators.c","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.c","text":"c(\n    indices...;\n    scalar_type\n) -> KeldyshED.Operators.RealOperatorExpr\n\n\nMake an annihilation operator c_alpha with indices... being components of the compound index alpha. Coefficient type of the resulting polynomial expression can be specified via scalar_type (defaults to Float64).\n\n\n\n\n\n","category":"function"},{"location":"operators/#KeldyshED.Operators.c_dag","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.c_dag","text":"c_dag(\n    indices...;\n    scalar_type\n) -> KeldyshED.Operators.RealOperatorExpr\n\n\nMake an creation operator c^dagger_alpha with indices... being components of the compound index alpha. Coefficient type of the resulting polynomial expression can be specified via scalar_type (defaults to Float64).\n\n\n\n\n\n","category":"function"},{"location":"operators/#KeldyshED.Operators.n","page":"Expressions with creation/annihilation operators of fermions","title":"KeldyshED.Operators.n","text":"n(\n    indices...;\n    scalar_type\n) -> KeldyshED.Operators.RealOperatorExpr\n\n\nMake a particle number operator n_alpha = c^dagger_alpha c_alpha with indices... being components of the compound index alpha. Coefficient type of the resulting polynomial expression can be specified via scalar_type (defaults to Float64).\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#Exact-Diagonalization-solver","page":"Exact Diagonalization solver","title":"Exact Diagonalization solver","text":"","category":"section"},{"location":"ed_core/","page":"Exact Diagonalization solver","title":"Exact Diagonalization solver","text":"CurrentModule = KeldyshED","category":"page"},{"location":"ed_core/#Core-ED-types-and-functions","page":"Exact Diagonalization solver","title":"Core ED types and functions","text":"","category":"section"},{"location":"ed_core/","page":"Exact Diagonalization solver","title":"Exact Diagonalization solver","text":"EDCore\nEigenSystem\nEDCore(::OperatorExpr, ::SetOfIndices; ::Vector{OperatorExpr})\nBase.show(io::IO, ed::EDCore)\nc_connection\ncdag_connection\nmonomial_connection\nc_matrix\ncdag_matrix\nmonomial_matrix\noperator_blocks","category":"page"},{"location":"ed_core/#KeldyshED.EDCore","page":"Exact Diagonalization solver","title":"KeldyshED.EDCore","text":"Lightweight Exact Diagonalization solver for finite systems of fermions.\n\nFields\n\nfull_hs::KeldyshED.Hilbert.FullHilbertSpace: Full Hilbert space of the system.\nsubspaces::Vector{KeldyshED.Hilbert.HilbertSubspace}: List of the invariant subspaces of the Hamiltonian.\neigensystems::Vector{KeldyshED.EigenSystem}: Eigensystems of the Hamiltonian within the invariant subspaces.\ncreation_connection::Vector{Dict{Int64, Int64}}: Subspace-to-subspace connections generated by the creation operators c^dagger_i. If a creation operator, whose compound index i translates into a linear index l by full_hs.soi, acts between subspaces s and s, then creation_connection[l][s] = s'.\n\nannihilation_connection::Vector{Dict{Int64, Int64}}: Subspace-to-subspace connections generated by the annihilation operators c_i. If an annihilation operator, whose compound index i translates into a linear index l by full_hs.soi, acts between subspaces s and s, then annihilation_connection[l][s] = s'.\n\ncdag_matrices::Array{Dict{Int64, Matrix{ScalarType}}, 1} where ScalarType<:Number: Matrices of the creation operators c^dagger_i in the eigenbasis of the Hamiltonian. If a creation operator, whose compound index i translates into a linear index l by full_hs.soi, acts between subspaces s and s, then the corresponding block of its matrix form is available as cdag_matrices[l][s].\n\nc_matrices::Array{Dict{Int64, Matrix{ScalarType}}, 1} where ScalarType<:Number: Matrices of the annihilation operators c_i  in the eigenbasis of the Hamiltonian. If an annihilation operator, whose compound index i translates into a linear index l by full_hs.soi, acts between subspaces s and s, then the corresponding block of its matrix form is available as c_matrices[l][s].\n\ngs_energy::Float64: Ground state energy of the system.\n\n\n\n\n\n","category":"type"},{"location":"ed_core/#KeldyshED.EigenSystem","page":"Exact Diagonalization solver","title":"KeldyshED.EigenSystem","text":"Partial eigensystem within one invariant subspace of the Hamiltonian.\n\nFields\n\neigenvalues::Vector{Float64}: Eigenvalues E_n of the Hamiltonian hat H, in ascending order. The energy reference point is shifted so that the global energy minimum is zero.\n\nunitary_matrix::Matrix{ScalarType} where ScalarType<:Number: Unitary transformation matrix hat U from the Fock basis to the eigenbasis, hat H = hat U mathrmdiag(E_n) hat U^dagger.\n\n\n\n\n\n","category":"type"},{"location":"ed_core/#KeldyshED.EDCore-Tuple{KeldyshED.Operators.OperatorExpr, KeldyshED.Hilbert.SetOfIndices}","page":"Exact Diagonalization solver","title":"KeldyshED.EDCore","text":"EDCore(\n    hamiltonian::KeldyshED.Operators.OperatorExpr{S<:Number},\n    soi::KeldyshED.Hilbert.SetOfIndices;\n    symmetry_breakers\n) -> EDCore\n\n\nReduce a given Hamiltonian to a block-diagonal form and diagonalize it.\n\nThis constructor uses the autopartition procedure, and the QR algorithm to diagonalize the blocks. The invariant subspaces of the Hamiltonian are chosen such that all creation and annihilation operators carrying compound indices from the provided set soi map one subspace to one subspace.\n\nIt is possible to pass an optional list of operator expressions (symmetry_breakers) that are required to share invariant subspaces with the Hamiltonian. As those operators can break some symmetries of the Hamiltonian, taking them into account can result in a less refined subspace partition and block structure.\n\n\n\n\n\n","category":"method"},{"location":"ed_core/#Base.show-Tuple{IO, EDCore}","page":"Exact Diagonalization solver","title":"Base.show","text":"show(io::IO, ed::EDCore)\n\n\nPrint various information about solution of an Exact Diagonalization problem.\n\n\n\n\n\n","category":"method"},{"location":"ed_core/#KeldyshED.c_connection","page":"Exact Diagonalization solver","title":"KeldyshED.c_connection","text":"c_connection(\n    ed::EDCore,\n    op_linear_index::Int64,\n    sp_index::Int64\n) -> Union{Nothing, Int64}\n\n\nExtract a subspace-to-subspace connection generated by an annihilation operator from an Exact Diagonalization solver. Returns nothing if no such connection exists.\n\nArguments\n\ned:              The Exact Diagonalization solver object.\nop_linear_index: Linear index of the annihilation operator as defined by                    ed.full_hs.soi.\nsp_index:        Initial subspace index.\n\n\n\n\n\nc_connection(\n    ed::EDCore,\n    indices::Vector{Union{Int64, String}},\n    sp_index::Int64\n) -> Union{Nothing, Int64}\n\n\nExtract a subspace-to-subspace connection generated by an annihilation operator from an Exact Diagonalization solver. Returns nothing if no such connection exists.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nindices:  Compound index of the annihilation operator (must be part of             ed.full_hs.soi).\nsp_index: Initial subspace index.\n\n\n\n\n\nc_connection(\n    ed::EDCore,\n    op_linear_index::Int64\n) -> BitMatrix\n\n\nExtract a matrix of subspace-to-subspace connections generated by an annihilation operator from an Exact Diagonalization solver. This method returns a square boolean matrix of size length(ed.subspaces) with true elements corresponding to the existing connections between the subspaces.\n\nArguments\n\ned:              The Exact Diagonalization solver object.\nop_linear_index: Linear index of the annihilation operator as defined by                    ed.full_hs.soi.\n\n\n\n\n\nc_connection(\n    ed::EDCore,\n    indices::Vector{Union{Int64, String}}\n) -> BitMatrix\n\n\nExtract a matrix of subspace-to-subspace connections generated by an annihilation operator from an Exact Diagonalization solver. This method returns a square boolean matrix of size length(ed.subspaces) with true elements corresponding to the existing connections between the subspaces.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nindices:  Compound index of the annihilation operator (must be part of             ed.full_hs.soi).\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#KeldyshED.cdag_connection","page":"Exact Diagonalization solver","title":"KeldyshED.cdag_connection","text":"cdag_connection(\n    ed::EDCore,\n    op_linear_index::Int64,\n    sp_index::Int64\n) -> Union{Nothing, Int64}\n\n\nExtract a subspace-to-subspace connection generated by a creation operator from an Exact Diagonalization solver. Returns nothing if no such connection exists.\n\nArguments\n\ned:              The Exact Diagonalization solver object.\nop_linear_index: Linear index of the creation operator as defined by ed.full_hs.soi.\nsp_index:        Initial subspace index.\n\n\n\n\n\ncdag_connection(\n    ed::EDCore,\n    indices::Vector{Union{Int64, String}},\n    sp_index::Int64\n) -> Union{Nothing, Int64}\n\n\nExtract a subspace-to-subspace connection generated by a creation operator from an Exact Diagonalization solver. Returns nothing if no such connection exists.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nindices:  Compound index of the creation operator (must be part of ed.full_hs.soi).\nsp_index: Initial subspace index.\n\n\n\n\n\ncdag_connection(\n    ed::EDCore,\n    op_linear_index::Int64\n) -> BitMatrix\n\n\nExtract a matrix of subspace-to-subspace connections generated by a creation operator from an Exact Diagonalization solver. This method returns a square boolean matrix of size length(ed.subspaces) with true elements corresponding to the existing connections between the subspaces.\n\nArguments\n\ned:              The Exact Diagonalization solver object.\nop_linear_index: Linear index of the creation operator as defined by ed.full_hs.soi.\n\n\n\n\n\ncdag_connection(\n    ed::EDCore,\n    indices::Vector{Union{Int64, String}}\n) -> BitMatrix\n\n\nExtract a matrix of subspace-to-subspace connections generated by a creation operator from an Exact Diagonalization solver. This method returns a square boolean matrix of size length(ed.subspaces) with true elements corresponding to the existing connections between the subspaces.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nindices:  Compound index of the creation operator (must be part of ed.full_hs.soi).\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#KeldyshED.monomial_connection","page":"Exact Diagonalization solver","title":"KeldyshED.monomial_connection","text":"monomial_connection(\n    ed::EDCore,\n    mon::KeldyshED.Operators.Monomial,\n    sp_index::Int64\n) -> Union{Nothing, Int64}\n\n\nExtract a subspace-to-subspace connection generated by a monomial operator (a product of canonical operators c/c^dagger) from an Exact Diagonalization solver. Returns nothing if no such connection exists.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nmon:      Monomial in question.\nsp_index: Initial subspace index.\n\n\n\n\n\nmonomial_connection(\n    ed::EDCore,\n    mon::KeldyshED.Operators.Monomial\n) -> BitMatrix\n\n\nExtract a matrix of subspace-to-subspace connections generated by a monomial operator (a product of canonical operators c/c^dagger) from an Exact Diagonalization solver. This method returns a square boolean matrix of size length(ed.subspaces) with true elements corresponding to the existing connections between the subspaces.\n\nArguments\n\ned:  The Exact Diagonalization solver object.\nmon: Monomial in question.\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#KeldyshED.c_matrix","page":"Exact Diagonalization solver","title":"KeldyshED.c_matrix","text":"c_matrix(\n    ed::EDCore,\n    op_linear_index::Int64,\n    sp_index::Int64\n) -> Matrix{ScalarType} where ScalarType<:Number\n\n\nExtract a non-vanishing matrix block of an annihilation operator from an Exact Diagonalization solver. The block is written in the eigenbasis of the Hamiltonian.\n\nArguments\n\ned:              The Exact Diagonalization solver object.\nop_linear_index: Linear index of the annihilation operator as defined by                    ed.full_hs.soi.\nsp_index:        Initial subspace index.\n\nThe final subspace index is uniquely determined by the pair (op_linear_index, sp_index) as there is at most one non-vanishing matrix per such a pair.\n\n\n\n\n\nc_matrix(\n    ed::EDCore,\n    indices::Vector{Union{Int64, String}},\n    sp_index::Int64\n) -> Matrix{ScalarType} where ScalarType<:Number\n\n\nExtract a non-vanishing matrix block of an annihilation operator from an Exact Diagonalization solver. The block is written in the eigenbasis of the Hamiltonian.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nindices:  Compound index of the annihilation operator (must be part of             ed.full_hs.soi).\nsp_index: Initial subspace index.\n\nThe final subspace index is uniquely determined by the pair (indices, sp_index) as there is at most one non-vanishing matrix per such a pair.\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#KeldyshED.cdag_matrix","page":"Exact Diagonalization solver","title":"KeldyshED.cdag_matrix","text":"cdag_matrix(\n    ed::EDCore,\n    op_linear_index::Int64,\n    sp_index::Int64\n) -> Matrix{ScalarType} where ScalarType<:Number\n\n\nExtract a non-vanishing matrix block of a creation operator from an Exact Diagonalization solver. The block is written in the eigenbasis of the Hamiltonian.\n\nArguments\n\ned:              The Exact Diagonalization solver object.\nop_linear_index: Linear index of the creation operator as defined by                    ed.full_hs.soi.\nsp_index:        Initial subspace index.\n\nThe final subspace index is uniquely determined by the pair (op_linear_index, sp_index) as there is at most one non-vanishing matrix per such a pair.\n\n\n\n\n\ncdag_matrix(\n    ed::EDCore,\n    indices::Vector{Union{Int64, String}},\n    sp_index::Int64\n) -> Matrix{ScalarType} where ScalarType<:Number\n\n\nExtract a non-vanishing matrix block of a creation operator from an Exact Diagonalization solver. The block is written in the eigenbasis of the Hamiltonian.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nindices:  Compound index of the creation operator (must be part of             ed.full_hs.soi).\nsp_index: Initial subspace index.\n\nThe final subspace index is uniquely determined by the pair (indices, sp_index) as there is at most one non-vanishing matrix per such a pair.\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#KeldyshED.monomial_matrix","page":"Exact Diagonalization solver","title":"KeldyshED.monomial_matrix","text":"monomial_matrix(\n    ed::EDCore{ScalarType<:Number},\n    mon::KeldyshED.Operators.Monomial,\n    sp_index::Int64\n) -> Any\n\n\nExtract a non-vanishing matrix block a monomial operator (a product of canonical operators c/c^dagger) from an Exact Diagonalization solver. The block is written in the eigenbasis of the Hamiltonian.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nmon:      Monomial in question.\nsp_index: Initial subspace index.\n\nThe final subspace index is uniquely determined by the pair (mon, sp_index) as there is at most one non-vanishing matrix per such a pair.\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#KeldyshED.operator_blocks","page":"Exact Diagonalization solver","title":"KeldyshED.operator_blocks","text":"operator_blocks(\n    ed::EDCore{EDScalarType<:Number},\n    op::KeldyshED.Operators.OperatorExpr{OPScalarType<:Number},\n    sp_index::Int64\n) -> Dict{Int64, Matrix{_A}} where _A\n\n\nCompute blocks of the matrix representation of an operator acting on states in a given (initial) subspace. The computed blocks are returned as a dictionary final subspace index => matrix, and the matrices are written in the eigenbasis of the Hamiltonian.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nop:       Operator expression.\nsp_index: Initial subspace index.\n\n\n\n\n\noperator_blocks(\n    ed::EDCore{EDScalarType<:Number},\n    op::KeldyshED.Operators.OperatorExpr{OPScalarType<:Number}\n) -> Dict{Tuple{Int64, Int64}, Matrix{_A}} where _A\n\n\nCompute blocks of the matrix representation of an operator.\n\nThe computed blocks are returned as a dictionary (initial subspace index, final subspace index) => matrix, and the matrices are written in the eigenbasis of the Hamiltonian.\n\nArguments\n\ned:       The Exact Diagonalization solver object.\nop:       Operator expression.\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#Utility-functions","page":"Exact Diagonalization solver","title":"Utility functions","text":"","category":"section"},{"location":"ed_core/","page":"Exact Diagonalization solver","title":"Exact Diagonalization solver","text":"fock_states\nenergies\nunitary_matrices\ntofockbasis(M::Vector{Matrix{T}}, ed::EDCore) where T <: Number\ntoeigenbasis(M::Vector{Matrix{T}}, ed::EDCore) where T <: Number\nfull_hs_matrix","category":"page"},{"location":"ed_core/#KeldyshED.fock_states","page":"Exact Diagonalization solver","title":"KeldyshED.fock_states","text":"fock_states(ed::EDCore) -> Vector{Vector{UInt64}}\n\n\nCollect lists of basis Fock states spanning invariant subspaces stored in a given Exact Diagonalization object ed.\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#KeldyshED.energies","page":"Exact Diagonalization solver","title":"KeldyshED.energies","text":"energies(ed::EDCore) -> Vector{Vector{Float64}}\n\n\nCollect lists of energy levels from all invariant subspaces stored in a given Exact Diagonalization object ed.\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#KeldyshED.unitary_matrices","page":"Exact Diagonalization solver","title":"KeldyshED.unitary_matrices","text":"unitary_matrices(ed::EDCore) -> Vector\n\n\nCollect unitary transformation matrices hat U from all invariant subspaces stored in a given Exact Diagonalization object ed.\n\n\n\n\n\n","category":"function"},{"location":"ed_core/#KeldyshED.tofockbasis-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, EDCore}} where T<:Number","page":"Exact Diagonalization solver","title":"KeldyshED.tofockbasis","text":"tofockbasis(\n    M::Array{Array{T<:Number, 2}, 1},\n    ed::EDCore\n) -> Vector\n\n\nTransform a block-diagonal matrix written in the eigenbasis into the Fock state basis.\n\nArguments\n\nM:  List of matrices' diagonal blocks.\ned: An Exact Diagonalization object defining the invariant subspace structure and       partial eigenbases within the subspaces.\n\n\n\n\n\n","category":"method"},{"location":"ed_core/#KeldyshED.toeigenbasis-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, EDCore}} where T<:Number","page":"Exact Diagonalization solver","title":"KeldyshED.toeigenbasis","text":"toeigenbasis(\n    M::Array{Array{T<:Number, 2}, 1},\n    ed::EDCore\n) -> Vector\n\n\nTransform a block-diagonal matrix written in the Fock state basis into the eigenbasis.\n\nArguments\n\nM:  List of matrices' diagonal blocks.\ned: An Exact Diagonalization object defining the invariant subspace structure and       partial eigenbases within the subspaces.\n\n\n\n\n\n","category":"method"},{"location":"ed_core/#KeldyshED.full_hs_matrix","page":"Exact Diagonalization solver","title":"KeldyshED.full_hs_matrix","text":"full_hs_matrix(\n    M::Array{Array{T<:Number, 2}, 1},\n    ed::EDCore\n) -> Matrix{ScalarType} where ScalarType<:Number\n\n\nFlatten a block-diagonal matrix and return a matrix acting in the full Hilbert space.\n\nArguments\n\nM:  List of matrices' diagonal blocks.\ned: An Exact Diagonalization object defining the invariant subspace structure.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#Evolution-operators","page":"Density matrix and evolution operators","title":"Density matrix and evolution operators","text":"","category":"section"},{"location":"evolution/","page":"Density matrix and evolution operators","title":"Density matrix and evolution operators","text":"CurrentModule = KeldyshED","category":"page"},{"location":"evolution/","page":"Density matrix and evolution operators","title":"Density matrix and evolution operators","text":"partition_function\ndensity_matrix\nevolution_operator\ntofockbasis(::Vector{GF}, ::EDCore) where {GF <: AbstractTimeGF}\ntoeigenbasis(::Vector{GF}, ::EDCore) where {GF <: AbstractTimeGF}\npartial_trace\nreduced_density_matrix\nreduced_evolution_operator","category":"page"},{"location":"evolution/#KeldyshED.partition_function","page":"Density matrix and evolution operators","title":"KeldyshED.partition_function","text":"partition_function(ed::EDCore, β::Real) -> Real\n\n\nCompute the partition function Z = mathrmTre^-betahat H at an inverse temperature beta.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#KeldyshED.density_matrix","page":"Density matrix and evolution operators","title":"KeldyshED.density_matrix","text":"density_matrix(ed::EDCore, β::Real) -> Vector\n\n\nCompute the equilibrium density matrix hatrho = e^-betahat H  Z at an inverse temperature beta represented in the eigenbasis of the Hamiltonian hat H. The density matrix is returned as a vector of diagonal blocks corresponding to invariant subspaces of hat H.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#KeldyshED.evolution_operator","page":"Density matrix and evolution operators","title":"KeldyshED.evolution_operator","text":"evolution_operator(\n    ed::EDCore,\n    grid::Keldysh.AbstractTimeGrid\n) -> Vector{Keldysh.GenericTimeGF{ComplexF64, false}}\n\n\nCompute the evolution operator\n\n    hat S(t t) = expleft(-i int_t^t hat H dbar tright)\n\non a given contour time grid and represented in the eigenbasis of the Hamiltonian hat H. The operator is returned as a vector of diagonal blocks (matrix-valued Green's function containers) corresponding to invariant subspaces of hat H.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#KeldyshED.tofockbasis-Union{Tuple{GF}, Tuple{Vector{GF}, EDCore}} where GF<:Keldysh.AbstractTimeGF","page":"Density matrix and evolution operators","title":"KeldyshED.tofockbasis","text":"tofockbasis(\n    S::Array{GF<:Keldysh.AbstractTimeGF, 1},\n    ed::EDCore\n) -> Vector{GF} where GF<:Keldysh.AbstractTimeGF\n\n\nTransform a block-diagonal evolution operator S written in the eigenbasis of the system into the Fock state basis.\n\n\n\n\n\n","category":"method"},{"location":"evolution/#KeldyshED.toeigenbasis-Union{Tuple{GF}, Tuple{Vector{GF}, EDCore}} where GF<:Keldysh.AbstractTimeGF","page":"Density matrix and evolution operators","title":"KeldyshED.toeigenbasis","text":"toeigenbasis(\n    S::Array{GF<:Keldysh.AbstractTimeGF, 1},\n    ed::EDCore\n) -> Vector{GF} where GF<:Keldysh.AbstractTimeGF\n\n\nTransform a block-diagonal evolution operator S written in the Fock state basis into the eigenbasis of the system.\n\n\n\n\n\n","category":"method"},{"location":"evolution/#KeldyshED.partial_trace","page":"Density matrix and evolution operators","title":"KeldyshED.partial_trace","text":"partial_trace(\n    M::Array{Array{T, 2}, 1},\n    ed::EDCore,\n    target_soi::KeldyshED.Hilbert.SetOfIndices\n) -> Union{Array{Float64, 3}, Matrix}\n\n\nCompute a partial trace of a block-diagonal matrix M.\n\nThe matrix is expected to be written in the Fock state basis. The resulting reduced matrix acts in a Hilbert space spanned by all fermionic Fock states generated by the set of indices target_soi.\n\n\n\n\n\npartial_trace(\n    S::Array{GF<:Keldysh.AbstractTimeGF, 1},\n    ed::EDCore,\n    target_soi::KeldyshED.Hilbert.SetOfIndices\n) -> Any\n\n\nCompute a partial trace of a block-diagonal evolution operator S written in the Fock state basis.\n\nThe resulting reduced evolution operator acts in a Hilbert space spanned by all fermionic Fock states generated by the set of indices target_soi.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#KeldyshED.reduced_density_matrix","page":"Density matrix and evolution operators","title":"KeldyshED.reduced_density_matrix","text":"reduced_density_matrix(\n    ed::EDCore,\n    target_soi::KeldyshED.Hilbert.SetOfIndices,\n    β::Real\n) -> Any\n\n\nCompute a reduced equilibrium density matrix\n\nhatrho_target = mathrmTr_enve^-betahat H  Z\n\nat an inverse temperature beta.\n\nThe Hamiltonian hat H acts in a direct product of Hilbert spaces H_target otimes H_env, while the resulting reduced matrix acts in H_target spanned by all fermionic Fock states generated by the set of indices target_soi.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#KeldyshED.reduced_evolution_operator","page":"Density matrix and evolution operators","title":"KeldyshED.reduced_evolution_operator","text":"reduced_evolution_operator(\n    ed::EDCore,\n    target_soi::KeldyshED.Hilbert.SetOfIndices,\n    grid::Keldysh.AbstractTimeGrid\n) -> Keldysh.GenericTimeGF{ComplexF64}\n\n\nCompute a reduced evolution operator\n\nhat S_target(t t) =\nmathrmTr_envleftexpleft(-i int_t^t hat H dbar tright)right\n\non a given contour time grid.\n\nThe Hamiltonian hat H acts in a direct product of Hilbert spaces H_target otimes H_env, while the resulting reduced evolution operator acts in H_target spanned by all fermionic Fock states generated by the set of indices target_soi.\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#Hilbert-spaces,-states-and-linear-operators","page":"Hilbert spaces, states and linear operators","title":"Hilbert spaces, states and linear operators","text":"","category":"section"},{"location":"hilbert/","page":"Hilbert spaces, states and linear operators","title":"Hilbert spaces, states and linear operators","text":"KeldyshED.Hilbert","category":"page"},{"location":"hilbert/#KeldyshED.Hilbert","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert","text":"This module defines types of Hilbert spaces, state vectors and linear operators acting in these spaces. It also implements the space autopartition algorithm described in Computer Physics Communications 200, March 2016, 274-284 (section 4.2).\n\n\n\n\n\n","category":"module"},{"location":"hilbert/","page":"Hilbert spaces, states and linear operators","title":"Hilbert spaces, states and linear operators","text":"CurrentModule = KeldyshED.Hilbert","category":"page"},{"location":"hilbert/#Ordered-set-of-compound-indices","page":"Hilbert spaces, states and linear operators","title":"Ordered set of compound indices","text":"","category":"section"},{"location":"hilbert/","page":"Hilbert spaces, states and linear operators","title":"Hilbert spaces, states and linear operators","text":"Hilbert.SetOfIndices\nBase.insert!(soi::SetOfIndices, indices::IndicesType)\nBase.insert!(soi::SetOfIndices, indices...)\nreversemap(soi::SetOfIndices)\nmatching_indices","category":"page"},{"location":"hilbert/#KeldyshED.Hilbert.SetOfIndices","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.SetOfIndices","text":"Mapping from a compound operator index IndicesType to a linear integer index. It provides a dictionary-like iteration interface, supports indexed read-only access, functions keys(), values() and pairs(), as well as the operator in.\n\nFields\n\nmap_index_n::DataStructures.SortedDict{Vector{Union{Int64, String}}, Int64}: The IndicesType -> linear index map\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#Base.insert!-Tuple{KeldyshED.Hilbert.SetOfIndices, Vector{Union{Int64, String}}}","page":"Hilbert spaces, states and linear operators","title":"Base.insert!","text":"insert!(\n    soi::KeldyshED.Hilbert.SetOfIndices,\n    indices::Vector{Union{Int64, String}}\n) -> DataStructures.SortedDict{Vector{Union{Int64, String}}, Int64, Base.Order.ForwardOrdering}\n\n\nInsert a new compound operator index indices into soi.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#Base.insert!-Tuple{KeldyshED.Hilbert.SetOfIndices, Vararg{Any}}","page":"Hilbert spaces, states and linear operators","title":"Base.insert!","text":"insert!(\n    soi::KeldyshED.Hilbert.SetOfIndices,\n    indices...\n) -> DataStructures.SortedDict{Vector{Union{Int64, String}}, Int64, Base.Order.ForwardOrdering}\n\n\nInsert a new compound operator index built out of arguments indices... into soi.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#KeldyshED.Hilbert.reversemap-Tuple{KeldyshED.Hilbert.SetOfIndices}","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.reversemap","text":"reversemap(\n    soi::KeldyshED.Hilbert.SetOfIndices\n) -> Vector{Vector{Union{Int64, String}}}\n\n\nBuild and return the reverse map Int -> IndicesType out of a SetOfIndices object.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#KeldyshED.Hilbert.matching_indices","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.matching_indices","text":"matching_indices(\n    soi_from::KeldyshED.Hilbert.SetOfIndices,\n    soi_to::KeldyshED.Hilbert.SetOfIndices\n) -> Vector{Int64}\n\n\nFor each compound index in the set soi_from, find the linear index of that compound index within soi_to and collect the found linear indices.\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#Full-Hilbert-spaces-and-their-subspaces","page":"Hilbert spaces, states and linear operators","title":"Full Hilbert spaces and their subspaces","text":"","category":"section"},{"location":"hilbert/","page":"Hilbert spaces, states and linear operators","title":"Hilbert spaces, states and linear operators","text":"FockState\ntranslate\nHilbertSpace\nFullHilbertSpace\nFullHilbertSpace(soi::SetOfIndices)\ngetindex(fhs::FullHilbertSpace, soi_indices::Set{IndicesType})\n(⊗)(H_A::FullHilbertSpace, H_B::FullHilbertSpace)\n(/)(H_AB::FullHilbertSpace, H_A::FullHilbertSpace)\nproduct_basis_map\nfactorized_basis_map\nHilbertSubspace\nBase.insert!(hss::HilbertSubspace, fs::FockState)\ngetstateindex","category":"page"},{"location":"hilbert/#KeldyshED.Hilbert.FockState","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.FockState","text":"primitive type UInt64 <: Unsigned 64\n\nFermionic Fock state encoded as a sequence of zeros (unoccupied single-particle states) and ones (occupied states) in the binary representation of an integer.\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#KeldyshED.Hilbert.translate","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.translate","text":"translate(\n    fs::UInt64,\n    bit_map::Vector{Int64};\n    reverse\n) -> UInt64\n\n\nReshuffle single-particle states (bits) of a Fock state fs according to a given map bit_map. bit_map is understood as a reverse map if reverse = true.\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#KeldyshED.Hilbert.HilbertSpace","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.HilbertSpace","text":"Abstract supertype for Hilbert space types.\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#KeldyshED.Hilbert.FullHilbertSpace","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.FullHilbertSpace","text":"A Hilbert space spanned by all fermionic Fock states generated by a given set of creation/annihilation operators. This type supports vector-like iteration over Fock states, read-only indexed access and the operator in.\n\nFields\n\nsoi::KeldyshED.Hilbert.SetOfIndices: Set of compound operator indices used to generate this space\ndim::UInt64: Dimension of the space\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#KeldyshED.Hilbert.FullHilbertSpace-Tuple{KeldyshED.Hilbert.SetOfIndices}","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.FullHilbertSpace","text":"FullHilbertSpace(\n    soi::KeldyshED.Hilbert.SetOfIndices\n) -> KeldyshED.Hilbert.FullHilbertSpace\n\n\nMake a Hilbert space generated by creation/annihilation operators carrying compound indices from a given set soi.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#Base.getindex-Tuple{KeldyshED.Hilbert.FullHilbertSpace, Set{Vector{Union{Int64, String}}}}","page":"Hilbert spaces, states and linear operators","title":"Base.getindex","text":"getindex(\n    fhs::KeldyshED.Hilbert.FullHilbertSpace,\n    soi_indices::Set{Vector{Union{Int64, String}}}\n) -> UInt64\n\n\nReturn the Fock state psirangle propto c^dagger_i c^dagger_j c^dagger_k ldots 0rangle, where the compound indices ijkldots form a given set soi_indices and the creation operators act in a Hilbert space fhs.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#KeldyshED.Hilbert.:⊗-Tuple{KeldyshED.Hilbert.FullHilbertSpace, KeldyshED.Hilbert.FullHilbertSpace}","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.:⊗","text":"⊗(\n    H_A::KeldyshED.Hilbert.FullHilbertSpace,\n    H_B::KeldyshED.Hilbert.FullHilbertSpace\n) -> KeldyshED.Hilbert.FullHilbertSpace\n\n\nConstruct a direct product of full Hilbert spaces H_A otimes H_B under the assumption that the sets of indices generating H_A and H_B are disjoint.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#Base.:/-Tuple{KeldyshED.Hilbert.FullHilbertSpace, KeldyshED.Hilbert.FullHilbertSpace}","page":"Hilbert spaces, states and linear operators","title":"Base.:/","text":"/(\n    H_AB::KeldyshED.Hilbert.FullHilbertSpace,\n    H_A::KeldyshED.Hilbert.FullHilbertSpace\n) -> KeldyshED.Hilbert.FullHilbertSpace\n\n\nConstruct a quotient space H_AB  H_A under the assumption that the sets of indices generating H_AB and H_A satisfy soi(H_A) subseteq soi(H_AB).\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#KeldyshED.Hilbert.product_basis_map","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.product_basis_map","text":"product_basis_map(\n    H_A::KeldyshED.Hilbert.FullHilbertSpace,\n    H_B::KeldyshED.Hilbert.FullHilbertSpace,\n    H_AB::KeldyshED.Hilbert.FullHilbertSpace\n) -> Matrix{Int64}\n\n\nGiven three Hilbert spaces H_A, H_B and H_AB, construct all product Fock states psirangle_AB = psirangle_A  psirangle_B, where psirangle_A  H_A psirangle_B  H_B psirangle_AB  H_AB. Return a mapping (an integer-valued matrix) i j mapsto k, where i, j and k are linear indices of psirangle_A, psirangle_B and psirangle_AB within their respective spaces.\n\nSets of indices soi(H_A), soi(H_B) must be disjoint and satisfy soi(H_A) subseteq soi(H_AB), soi(H_B) subseteq soi(H_AB).\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#KeldyshED.Hilbert.factorized_basis_map","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.factorized_basis_map","text":"factorized_basis_map(\n    H_AB::KeldyshED.Hilbert.FullHilbertSpace,\n    H_A::KeldyshED.Hilbert.FullHilbertSpace\n) -> Vector{Tuple{Int64, Int64}}\n\n\nGiven a Hilbert space H_AB and its divisor H_A, factorize all Fock states psirangle_AB in H_AB into a direct product psirangle_A otimes psirangle_B, where psirangle_A in H_A, psirangle_B in H_AB  H_A. Return a mapping (a vector of integer pairs) k mapsto (i j), where i, j and k are linear indices of psirangle_A, psirangle_B and psirangle_AB within their respective spaces.\n\nSets of indices soi(H_AB), soi(H_A) must satisfy soi(H_A) subseteq soi(H_AB).\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#KeldyshED.Hilbert.HilbertSubspace","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.HilbertSubspace","text":"Subspace of a Hilbert space, as a list of basis Fock states.\n\nThis type supports vector-like iteration over Fock states, read-only indexed access and the operator in.\n\nFields\n\nfock_states::Vector{UInt64}: List of all Fock states spanning the space\nfock_to_index::Dict{UInt64, Int64}: Reverse map to quickly find the index of a basis Fock state\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#Base.insert!-Tuple{KeldyshED.Hilbert.HilbertSubspace, UInt64}","page":"Hilbert spaces, states and linear operators","title":"Base.insert!","text":"insert!(\n    hss::KeldyshED.Hilbert.HilbertSubspace,\n    fs::UInt64\n) -> Int64\n\n\nInsert a basis Fock state fs into a subspace hss.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#KeldyshED.Hilbert.getstateindex","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.getstateindex","text":"getstateindex(\n    fhs::KeldyshED.Hilbert.FullHilbertSpace,\n    fs::UInt64\n) -> Int64\n\n\nFind the index of a given Fock state fs within a full Hilbert space fhs.\n\n\n\n\n\ngetstateindex(\n    hss::KeldyshED.Hilbert.HilbertSubspace,\n    fs::UInt64\n) -> Int64\n\n\nFind the index of a given Fock state fs within a subspace hss.\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#Quantum-states","page":"Hilbert spaces, states and linear operators","title":"Quantum states","text":"","category":"section"},{"location":"hilbert/","page":"Hilbert spaces, states and linear operators","title":"Hilbert spaces, states and linear operators","text":"State\nStateVector\nStateVector(hs)\nStateDict\nStateDict(hs)\nBase.similar\ndot\nproject\nBase.show(io::IO, sv::StateVector{HSType, S}) where {HSType, S}\nBase.show(io::IO, sd::StateDict{HSType, S}) where {HSType, S}","category":"page"},{"location":"hilbert/#KeldyshED.Hilbert.State","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.State","text":"Abstract supertype of quantum state types\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#KeldyshED.Hilbert.StateVector","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.StateVector","text":"Quantum state in a Hilbert space/subspace implemented as a vector of amplitudes.\n\nThe amplitudes can be accessed using the indexing interface and iterated over. States support addition/subtraction and multiplication/division by a constant scalar.\n\nFields\n\nhs::KeldyshED.Hilbert.HilbertSpace: Hilbert space this state belongs to\namplitudes::Vector: Amplitudes of basis states contributing to this state\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#KeldyshED.Hilbert.StateVector-Tuple{Any}","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.StateVector","text":"StateVector{HSType, S}(hs::HSType) where {HSType, S}\n\nCreate a vector-based state in a Hilbert space/subspace hs with all amplitudes set to zero.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#KeldyshED.Hilbert.StateDict","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.StateDict","text":"Quantum state in a Hilbert space/subspace implemented as a (sparse) dictionary of amplitudes.\n\nThe amplitudes can be accessed using the indexing interface and iterated over. States support addition/subtraction and multiplication/division by a constant scalar.\n\nFields\n\nhs::KeldyshED.Hilbert.HilbertSpace: Hilbert space this state belongs to\namplitudes::Dict{Int64}: Non-vanishing amplitudes of basis states contributing to this state. Each element of this dictionary is a pair (index of the basis state within hs, amplitude).\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#KeldyshED.Hilbert.StateDict-Tuple{Any}","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.StateDict","text":"StateDict{HSType, S}(hs::HSType) where {HSType, S}\n\nCreate a dictionary-based state in a Hilbert space/subspace hs with zero non-vanishing amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#Base.similar","page":"Hilbert spaces, states and linear operators","title":"Base.similar","text":"similar(\n    sv::KeldyshED.Hilbert.StateVector{HSType, S}\n) -> KeldyshED.Hilbert.StateVector\n\n\nCreate a vector-based state similar to sv with all amplitudes set to zero.\n\n\n\n\n\nsimilar(\n    sd::KeldyshED.Hilbert.StateDict{HSType, S}\n) -> KeldyshED.Hilbert.StateDict\n\n\nCreate a dictionary-based state similar to sd with zero non-vanishing amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#KeldyshED.Hilbert.dot","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.dot","text":"dot(\n    sv1::KeldyshED.Hilbert.StateVector,\n    sv2::KeldyshED.Hilbert.StateVector\n) -> Any\n\n\nCompute the scalar product of two vector-based states sv1 and sv2.\n\n\n\n\n\ndot(\n    sd1::KeldyshED.Hilbert.StateDict{HSType, S},\n    sd2::KeldyshED.Hilbert.StateDict{HSType, S}\n) -> Any\n\n\nCompute the scalar product of two dictionary-based states sd1 and sd2.\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#KeldyshED.Hilbert.project","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.project","text":"project(\n    sv::KeldyshED.Hilbert.StateVector{HSType, S},\n    target_space\n) -> KeldyshED.Hilbert.StateVector\n\n\nProject a vector-based state sv from one Hilbert space onto another Hilbert space/subspace target_space.\n\n\n\n\n\nproject(\n    sd::KeldyshED.Hilbert.StateDict{HSType, S},\n    target_space\n) -> KeldyshED.Hilbert.StateVector\n\n\nProject a dictionary-based state sd from one Hilbert space onto another Hilbert space/subspace target_space.\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#Base.show-Union{Tuple{S}, Tuple{HSType}, Tuple{IO, KeldyshED.Hilbert.StateVector{HSType, S}}} where {HSType, S}","page":"Hilbert spaces, states and linear operators","title":"Base.show","text":"show(io::IO, sv::KeldyshED.Hilbert.StateVector{HSType, S})\n\n\nPrint a vector-based state.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#Base.show-Union{Tuple{S}, Tuple{HSType}, Tuple{IO, KeldyshED.Hilbert.StateDict{HSType, S}}} where {HSType, S}","page":"Hilbert spaces, states and linear operators","title":"Base.show","text":"show(io::IO, sd::KeldyshED.Hilbert.StateDict{HSType, S})\n\n\nPrint a dictionary-based state.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#Operators-acting-in-Hilbert-spaces","page":"Hilbert spaces, states and linear operators","title":"Operators acting in Hilbert spaces","text":"","category":"section"},{"location":"hilbert/","page":"Hilbert spaces, states and linear operators","title":"Hilbert spaces, states and linear operators","text":"Operator\nOperator{HSType, S}(op_expr::OperatorExpr{S}, soi::SetOfIndices) where {\n    HSType, S}\n(*)(op::Operator, st::StateType) where {StateType <: State}","category":"page"},{"location":"hilbert/#KeldyshED.Hilbert.Operator","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.Operator","text":"Quantum-mechanical operator acting on states in a Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#KeldyshED.Hilbert.Operator-Union{Tuple{S}, Tuple{HSType}, Tuple{KeldyshED.Operators.OperatorExpr{S}, KeldyshED.Hilbert.SetOfIndices}} where {HSType, S}","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.Operator","text":"Operator{HSType, S}(op_expr::OperatorExpr{S}, soi::SetOfIndices) where {HSType, S}\n\nMake a linear operator acting on a Hilbert space/subspace out of a polynomial expression op_expr. The set soi is used to establish a correspondence between compound indices of creation/annihilation operators met in op_expr and the single-particle states – bits of FockState.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#Base.:*-Union{Tuple{StateType}, Tuple{KeldyshED.Hilbert.Operator, StateType}} where StateType<:KeldyshED.Hilbert.State","page":"Hilbert spaces, states and linear operators","title":"Base.:*","text":"*(\n    op::KeldyshED.Hilbert.Operator,\n    st::KeldyshED.Hilbert.State\n) -> Any\n\n\nAct with an operator op on a state st and return the resulting state.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#autopartition","page":"Hilbert spaces, states and linear operators","title":"Space autopartition algorithm","text":"","category":"section"},{"location":"hilbert/","page":"Hilbert spaces, states and linear operators","title":"Hilbert spaces, states and linear operators","text":"SpacePartition\nSpacePartition{HSType, S}(::HSType, ::OperatorType, ::Bool) where {\n    HSType <: HilbertSpace, S <: Number, OperatorType <: Operator}\nmerge_subspaces!\nnumsubspaces\nBase.getindex(sp::SpacePartition, index)","category":"page"},{"location":"hilbert/#KeldyshED.Hilbert.SpacePartition","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.SpacePartition","text":"Partition of a Hilbert space into a set of disjoint subspaces invariant under action of a given Hermitian operator (Hamiltonian).\n\nA detailed description of the algorithm can be found in Section 4.2 of Computer Physics Communications 200, March 2016, 274-284.\n\nSpacePartition supports iteration over pairs (index of a basis state of the Hilbert space, index of the invariant subspace that state belongs to).\n\nFields\n\nhs::KeldyshED.Hilbert.HilbertSpace: Full Hilbert space subject to partitioning\nsubspaces::DataStructures.IntDisjointSets: Disjoint set of subspaces\nroot_to_index::Dict{Int64, Int64}: Map root index to subspace index\nmatrix_elements::SparseArrays.SparseMatrixCSC{ScalarType, Int64} where ScalarType<:Number: Matrix elements of the Hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"hilbert/#KeldyshED.Hilbert.SpacePartition-Union{Tuple{OperatorType}, Tuple{S}, Tuple{HSType}, Tuple{HSType, OperatorType, Bool}} where {HSType<:KeldyshED.Hilbert.HilbertSpace, S<:Number, OperatorType<:KeldyshED.Hilbert.Operator}","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.SpacePartition","text":"SpacePartition{HSType, S}(hs::HSType,\n                          H::OperatorType,\n                          store_matrix_elements::Bool = true) where {\n    HSType <: HilbertSpace, S <: Number, OperatorType <: Operator}\n\nCreate a SpacePartition structure by performing Phase I of the automatic partitioning algorithm, i.e. discovering the invariant subspaces of the Hermitian operator H acting on the Hilbert space hs.\n\nIf store_matrix_elements = true, the field matrix_elements of the created structure contains a sparse-matrix representation of H.\n\n\n\n\n\n","category":"method"},{"location":"hilbert/#KeldyshED.Hilbert.merge_subspaces!","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.merge_subspaces!","text":"merge_subspaces!(sp, op)\nmerge_subspaces!(sp, op, store_matrix_elements)\n\n\nMerge some of the invariant subspaces in sp to ensure that the resulting subspaces are also invariant w.r.t. a given operator op.\n\nIf store_matrix_elements = true, a sparse-matrix representation of op is returned.\n\n\n\n\n\nmerge_subspaces!(sp, Cd, C)\nmerge_subspaces!(sp, Cd, C, store_matrix_elements)\n\n\nPerform Phase II of the automatic partition algorithm.\n\nMerge some of the invariant subspaces in sp to ensure that a given operator Cd and its Hermitian conjugate C generate only one-to-one connections between the subspaces.\n\nIf store_matrix_elements = true, a tuple of two sparse matrices representing Cd and C is returned.\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#KeldyshED.Hilbert.numsubspaces","page":"Hilbert spaces, states and linear operators","title":"KeldyshED.Hilbert.numsubspaces","text":"numsubspaces(sp::KeldyshED.Hilbert.SpacePartition) -> Int64\n\n\nReturn the number of subspaces in a space partition sp.\n\n\n\n\n\n","category":"function"},{"location":"hilbert/#Base.getindex-Tuple{KeldyshED.Hilbert.SpacePartition, Any}","page":"Hilbert spaces, states and linear operators","title":"Base.getindex","text":"getindex(\n    sp::KeldyshED.Hilbert.SpacePartition,\n    index\n) -> Int64\n\n\nFind the invariant subspace within a partition sp, the state with a given index belongs to.\n\n\n\n\n\n","category":"method"},{"location":"#KeldyshED","page":"Home","title":"KeldyshED","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package KeldyshED.jl is a small scale Equilibrium Exact Diagonalization solver for finite fermionic models. It can compute single-particle Green's functions in the (Matsubara) imaginary time domain, on the 2-branch Keldysh contour, and on the 3-branch Konstantinov-Perel' contour.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Its main intended use is solution of auxiliary problems required by more advanced solvers such as the Hybridization Expansion Quantum Monte Carlo and the N-crossing approximations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The initial public version of this package was a simplified Julia port of the TRIQS/atom_diag library, but has since acquired a number of unique features, e.g. calculation of Evolution operators.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KeldyshED.jl is a registered Julia package that can be installed via the following invocation","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"KeldyshED\")","category":"page"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KeldyshED","category":"page"},{"location":"#KeldyshED","page":"Home","title":"KeldyshED","text":"Equilibrium Exact Diagonalization library that can also compute Green's functions on the Keldysh contour.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"operators.md\",\n         \"hilbert.md\",\n         \"ed_core.md\",\n         \"gf.md\",\n         \"evolution.md\"]","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KeldyshED.jl is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.","category":"page"},{"location":"","page":"Home","title":"Home","text":"KeldyshED.jl is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should have received a copy of the GNU General Public License along with KeldyshED.jl (in the file LICENSE in this directory). If not, see http://www.gnu.org/licenses/.","category":"page"},{"location":"example/#Usage-example","page":"Usage example","title":"Usage example","text":"","category":"section"},{"location":"example/","page":"Usage example","title":"Usage example","text":"This example shows how to use KeldyshED to diagonalize a model Hamiltonian, a system of two coupled 2-orbital Hubbard-Kanamori atoms.","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"    beginalign*\n    hat H = sum_i=1^2 hat H_loci + hat H_hop\n    hat H_loci =\n    -mu sum_sigma sum_m=1^2 n_isigmam +\n    + U sum_m=1^2 n_iuparrowm n_idownarrowm\n    + (U - 2J) sum_mneq m=1^2\n        n_iuparrowm n_idownarrowm\n    + (U - 3J) sum_mm^2 sum_sigma\n        n_isigmam n_isigmam +\n    + J sum_mneq m=1^2\n       (c^dagger_iuparrowm c^dagger_idownarrowm\n        c_idownarrowm c_iuparrowm\n      + c^dagger_iuparrowm c^dagger_idownarrowm\n        c_idownarrowm c_iuparrowm)\n    hat H_hop = t sum_sigmasum_m=1^2\n        (c^dagger_1sigmam c_2sigmam + hc)\n    endalign*","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"using KeldyshED.Operators: IndicesType, OperatorExpr, c, c_dag, n\nusing KeldyshED.Hilbert: SetOfIndices\nusing KeldyshED: EDCore\n\nnorb = 2 # Number of orbitals\n\n# Construct a set of compound indices (atom, spin, orbital)\nsoi = SetOfIndices()\nfor atom in 1:2\n    for orb in 1:norb\n        insert!(soi, atom, \"up\", orb)\n        insert!(soi, atom, \"dn\", orb)\n    end\nend\n\n# Define system's Hamiltonian\nfunction make_hamiltonian(μ, U, J, t)\n    H = OperatorExpr{Float64}()\n\n    # Local terms\n    for atom in 1:2\n        for orb in 1:norb\n            H += -μ * (n(atom, \"up\", orb) + n(atom, \"dn\", orb))\n            H += U * n(atom, \"up\", orb) * n(atom, \"dn\", orb)\n        end\n\n        for orb1 in 1:norb, orb2 in 1:norb\n            orb1 == orb2 && continue\n            H += (U - 2 * J) * n(atom, \"up\", orb1) * n(atom, \"dn\", orb2)\n        end\n        for orb1 in 1:norb, orb2 in 1:norb\n            orb2 >= orb1 && continue\n            H += (U - 3 * J) * n(atom, \"up\", orb1) * n(atom, \"up\", orb2)\n            H += (U - 3 * J) * n(atom, \"dn\", orb1) * n(atom, \"dn\", orb2)\n        end\n        for orb1 in 1:norb, orb2 in 1:norb\n            orb1 == orb2 && continue\n            H += -J * c_dag(atom,\"up\", orb1) * c_dag(atom, \"dn\", orb1) *\n                    c(atom, \"up\", orb2) * c(atom, \"dn\", orb2)\n            H += -J * c_dag(atom,\"up\", orb1) * c_dag(atom, \"dn\", orb2) *\n                    c(atom, \"up\", orb2) * c(atom, \"dn\", orb1)\n        end\n    end\n\n    # Hopping terms between the two atoms\n    for spin in (\"up\", \"dn\")\n        for orb in 1:norb\n            H += t * (c_dag(1, spin, orb) * c(2, spin, orb) +\n                      c_dag(2, spin, orb) * c(1, spin, orb))\n        end\n    end\n\n    return H\nend\n\nH = make_hamiltonian(\n    1.0, # Chemical potential\n    3.0, # Hubbard interaction\n    0.3, # Hund coupling\n    0.5  # Hopping constant\n)\n\n# Diagonalize the system\ned = EDCore(H, soi)\n\nprintln(\"Hilbert space dimension: $(length(ed.full_hs))\")\nprintln(\"Dimensions of invariant subspaces (sectors) of the Hamiltonian:\")\nprintln(IOContext(stdout, :limit => true), length.(ed.subspaces))\nprintln(\"Ground state energy: $(ed.gs_energy)\")","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"Having diagonalized the Hamiltonian, we can calculate a single-particle Keldysh Green's function. Here, it is computed for atom 1 and for all combinations of spin and orbital indices. Time arguments of the Green's function are defined on a 3-branch Konstantinov-Perel' contour.","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"using Keldysh: FullContour, FullTimeGrid\nusing KeldyshED: computegf, DistributedGFFiller\n\ntmax = 10.0 # Maximum observation time on the real branches\nβ = 5.0     # Inverse temperature\n\n# `FullContour` stands for the 3-branch contour\ncontour = FullContour(; tmax=tmax, β=β)\n\nnt = 11 # Number of time points on each of the two real branches\nnτ = 5  # Number of time points on the imaginary branch\n\n# Discrete time grid on the contour\ngrid = FullTimeGrid(contour, nt, nτ)\n\n# List of compound indices of the Green's function\nop_indices = [IndicesType([1, spin, orb])\n              for spin in (\"up\", \"dn\") for orb in 1:norb]\n\n# `gf_filler = DistributedGFFiller()` instructs `computegf()` to use\n# a parallelized algorithm based on `Distributed.@distributed`\nG = computegf(ed,\n              grid,\n              op_indices, op_indices;\n              gf_filler = DistributedGFFiller())","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"One can also compute the evolution operator of the system,","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"    hat S(t t) = expleft(-i int_t^t hat H dbar tright)","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"and its reduced version","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"    hat S_1(t t) =\n    mathrmTr_2leftexpleft(-i int_t^t hat H dbar tright)right","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"where all degrees of freedom on the second atom are traced out.","category":"page"},{"location":"example/","page":"Usage example","title":"Usage example","text":"using KeldyshED: evolution_operator, reduced_evolution_operator\n\nS = evolution_operator(ed, grid)\n\n# Compound indices on the first atom\nsoi1 = SetOfIndices()\nfor orb in 1:norb\n    insert!(soi1, 1, \"up\", orb)\n    insert!(soi1, 1, \"dn\", orb)\nend\nS_1 = reduced_evolution_operator(ed, soi1, grid)","category":"page"}]
}
